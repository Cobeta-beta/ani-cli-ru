"""codegen Shikimori Api from official documentation"""
# mypy: ignore-errors

from typing import Optional, List, Tuple
import json
from dataclasses import dataclass, field
import re

from anicli_ru._http import client


BASE_URL = "https://shikimori.one"

SHIKIMORI_BASE = """
\"\"\"Autogenerated API from documentation\"\"\"
from requests import Response
from anicli_ru._http import client

__slots__ = ('ShikimoriAPI')


class ShikimoriAPI:
    def __init__(self):
        self.session = client()
"""


def concatenate_methods(cls_lst: List['Class']) -> str:
    """generate code from dataclasses"""
    names_camel_case = [c.title_camel_case for c in cls_lst]
    names_snake_case = [c.title_snake_case for c in cls_lst]
    methods = [f"\n        self.{name_snake} = {name_camel}(self.session)" for name_snake, name_camel in
               zip(names_snake_case, names_camel_case)]
    code = SHIKIMORI_BASE
    code += "".join(methods)
    code += "\n\n"
    code += "".join(str(cls) for cls in cls_lst)
    return code


@dataclass
class Param:
    name: str
    full_name: str
    description: str
    required: bool
    allow_nil: bool
    allow_blank: bool
    validator: str
    expected_type: str
    metadata: None
    show: bool
    validations: list
    # ex: topics method have extra params, and this ignore in codegen
    params: Optional[List[dict]] = field(default_factory=list)  # type: ignore

    def __str__(self):
        return f"{self.name} ({self.expected_type}). Required - {self.required}. {self.validator or ''}"


@dataclass
class Apis:
    api_url: str
    http_method: str
    short_description: str
    deprecated: Optional[bool]


@dataclass
class Method:
    doc_url: str
    name: str
    apis: List[Apis]
    formats: None
    full_description: str
    errors: list
    params: List[Param]
    returns: list
    examples: list
    metadata: None
    see: list
    headers: list
    show: bool

    def __init__(self, **kwargs):
        for key, value in kwargs.items():
            if key == "params":
                setattr(self, key, [Param(**val) for val in value])
            elif key == "apis":
                setattr(self, key, [Apis(**val) for val in value])
            else:
                setattr(self, key, value)

    def doc(self, sep="    \n"):
        return [sep.join((str(p) for p in self.params))]

    @property
    def _required_param(self) -> Tuple[str, Optional[str]]:
        if rez := re.search(r"/(:\w+)/?", self.apis[0].api_url):
            rez = rez[1]  # type: ignore
            api_url = self.apis[0].api_url.replace(rez, f"{{{rez[1:]}}}")  # type: ignore
            required_param = rez[1:]  # type: ignore
            return f"{BASE_URL}{api_url}", required_param
        return f"{BASE_URL}{self.apis[0].api_url}", None

    @property
    def _docstring(self):
        return "\n            ".join((str(p) for p in self.params))

    def __str__(self):
        url, req_param = self._required_param
        if req_param:
            url = f"url = f'{url}'"
            header = f"def {self.name}(self, {req_param}, **kwargs)"
        else:
            url = f"url = '{url}'"
            header = f"def {self.name}(self, **kwargs)"
        return f"""
    {header} -> Response:
        \"\"\"{self.apis[0].short_description or ""}
    
        Deprecated:
            {self.apis[0].deprecated or False}
        
        Params:
            {self._docstring}
        \"\"\"
        {url}
        return self.session.request("{self.apis[0].http_method}", url, **kwargs)
    """


@dataclass
class Class:
    doc_url: str
    id: str
    api_url: str
    name: str
    short_description: None
    full_description: None
    version: str
    formats: None
    metadata: None
    headers: None
    deprecated: Optional[bool]
    methods: List[Method]

    @property
    def title_camel_case(self) -> str:
        return self.name.title().replace(" ", "")

    @property
    def title_snake_case(self) -> str:
        return self.name.lower().replace(" ", "_")

    def __init__(self, **kwargs):
        for key, value in kwargs.items():
            if key == "methods":
                setattr(self, key, [Method(**val) for val in value])
            else:
                setattr(self, key, value)

    def __str__(self):
        methods = (str(m) for m in self.methods)
        return f"""
class {self.title_camel_case}:
    \"\"\"{BASE_URL}{self.doc_url} 
    
    deprecated={self.deprecated or False}
    \"\"\"
    
    def __init__(self, session):
        self.session = session
    {"".join(methods)}
"""


class ShikimoriCodegen:
    DOC_URL = "https://shikimori.one/api/doc/1.0"
    BASE_URL = "https://shikimori.one"
    API_URL = "https://shikimori.one/api/"

    def __init__(self):
        # need set useragent, else return 403
        self.session = client()

    def get_documentation(self) -> dict:
        return self.session.get(self.DOC_URL).json()

    @staticmethod
    def _load_json(jsn_file: str):
        with open(jsn_file, "r") as f:
            return json.load(f)

    @classmethod
    def generate(cls, jsn_file: Optional[str] = None) -> str:
        doc = cls._load_json(jsn_file) if jsn_file else cls().get_documentation()["docs"]['resources']
        cls_lsts = [Class(**vals) for vals in doc.values()]
        return concatenate_methods(cls_lsts)


if __name__ == '__main__':
    code_ = ShikimoriCodegen.generate()
    with open("shikimori.py", "w") as f:
        f.write(code_)
